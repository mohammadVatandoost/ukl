/* Testing race while enabling lock elision.
   Copyright (C) 2018-2019 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <pthread.h>
#include <unistd.h>
#include <getopt.h>

static pthread_barrier_t barrier10;
static pthread_mutex_t mutex10;
static long long int iteration_count10 = 1000000;
static unsigned int thread_count10 = 3;

static void *
thr_func10 (void *arg)
{
  long long int i;
  for (i = 0; i < iteration_count10; i++)
    {
      if ((uintptr_t) arg == 0)
	{
	  pthread_mutex_destroy (&mutex10);
	  pthread_mutex_init (&mutex10, NULL);
	}

      pthread_barrier_wait (&barrier10);

      /* Test if enabling lock elision works if it is enabled concurrently.
	 There was a race in FORCE_ELISION macro which leads to either
	 pthread_mutex_destroy returning EBUSY as the owner was recorded
	 by pthread_mutex_lock - in "normal mutex10" code path - but was not
	 resetted in pthread_mutex_unlock - in "elision" code path.
	 Or it leads to the assertion in nptl/pthread_mutex_lock.c:
	 assert (mutex10->__data.__owner == 0);
	 Please ensure that the test is run with lock elision:
	 export GLIBC_TUNABLES=glibc.elision.enable=1  */
      pthread_mutex_lock (&mutex10);
      pthread_mutex_unlock (&mutex10);

      pthread_barrier_wait (&barrier10);
    }
  return NULL;
}

int
do_test10 (void)
{
  unsigned int i;
  printf ("Starting %d threads to run %lld iterations.\n",
	  thread_count10, iteration_count10);

  pthread_t *threads = malloc (thread_count10 * sizeof (pthread_t));
  pthread_barrier_init (&barrier10, NULL, thread_count10);
  pthread_mutex_init (&mutex10, NULL);

  for (i = 0; i < thread_count10; i++)
    threads[i] = pthread_create (NULL, thr_func10, (void *) (uintptr_t) i);

  for (i = 0; i < thread_count10; i++)
    pthread_join (threads[i]);

  pthread_barrier_destroy (&barrier10);
  free (threads);

  return EXIT_SUCCESS;
}

